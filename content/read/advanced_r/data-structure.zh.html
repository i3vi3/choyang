--- 
title: "数据结构"
date: "2017-09-24"
draft: true
---



<p>R 中常用的基础数据结构根据数据的维度（1维，2维，n维）和元素的性质（元素的类型是否相同 - 异质或同质）可分为以下几种：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>同质</th>
<th>异质</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1维</td>
<td>原子向量 - atomic vector</td>
<td>列表 - list</td>
</tr>
<tr class="even">
<td>2维</td>
<td>矩阵 - matrix</td>
<td>数据框 - data frame</td>
</tr>
<tr class="odd">
<td>n维</td>
<td>数组 - array</td>
<td></td>
</tr>
</tbody>
</table>
<p>其他复杂的类型的数据都是基于以上5种类型构建的.另外，R中不存在标量（0维数据，单个数字或字符），用长度为1的向量表征。函数<code>str()</code>（structure）用于显示对象的内部结构.</p>
<div class="section level2">
<h2>向量</h2>
<p>向量是 R 中最基本的数据结构，分为原子向量(atomic vector)和列表(list)两类，其中原子向量所有元素的类型必须一样，而列表则允许元素具有不同的数据类型。向量的三个基本特征为:</p>
<ul>
<li>类型: <code>typeof()</code>,其元素的类型.</li>
<li>长度: <code>length()</code>,元素个数.</li>
<li>属性： <code>attributes()</code>,额外的元数据.</li>
</ul>
<p><strong><code>is.vector()</code>仅当对象不含有属性（names 属性除外）的时候返回<code>TRUE</code>. <code>is.atomic(x) || is.list(x)</code>用于判断对象是否为向量.</strong></p>
<p><strong><code>mode()</code>和<code>storage.mode()</code>返回对象的模式(mode)或存储模式，是从 S 语言继承下来的函数，可以忽略，其中<code>storage.mode()</code>与<code>typeof()</code>作用一致. </strong></p>
<div class="section level3">
<h3>原子向量</h3>
<p>常见的原子向量有四种:logical,integer,double (numeric),character,此外，使用较少的 有complex和raw两种.原子向量用<code>c()</code>来创建.</p>
<pre class="r"><code>c(1.5, 2, 3)  # numeric
c(1L, 2L)     # L 表征为integer
c(TRUE, FALSE) # logical
c(&quot;a&quot;, &quot;b&quot;) # char</code></pre>
<p>缺失值<code>NA</code>是一个长度为1的逻辑向量,不同类型的向量中<code>NA</code>的类型也不同根据向量中元素的类型可分为 <code>NA_real_</code>, <code>NA_integer_</code>, <code>NA_character_</code>.</p>
<div class="section level4">
<h4>类型判断</h4>
<p><code>typeof()</code>用来显示对象的类型，<code>is.*()</code>可用来判定对象是否是某一特定类型:<code>is.character()</code>, <code>is.double()</code>, <code>is.integer()</code>, <code>is.logical()</code>, <code>is.atomic()</code>.</p>
<p>需要注意的是is.numeric当数据位integer或double时都返回TRUE</p>
</div>
<div class="section level4">
<h4>强制转换</h4>
<p>如前所述原子向量中元素的类型必须相同，当利用不同类型的数据创建向量时，向量中的元素都会被强制转化为最灵活的数据类型，由低到高的顺序为logical, integer, double, character.</p>
<pre class="r"><code>c(&quot;a&quot;, 1) # 数值转化为字符</code></pre>
<pre><code>## [1] &quot;a&quot; &quot;1&quot;</code></pre>
<pre class="r"><code>c(1L, 2.5) # 整形转化为实数</code></pre>
<pre><code>## [1] 1.0 2.5</code></pre>
<pre class="r"><code>c(TRUE, FALSE, 1) # TRUE、FALSE分别为1和0</code></pre>
<pre><code>## [1] 1 0 1</code></pre>
</div>
</div>
<div class="section level3">
<h3>列表</h3>
<p><code>list()</code>用于创建可包含不同类型元素的列表.</p>
<pre class="r"><code>x &lt;- list(1:3, &quot;a&quot;, c(TRUE, FALSE, TRUE), c(2.3, 5.9))
str(x)</code></pre>
<pre><code>## List of 4
##  $ : int [1:3] 1 2 3
##  $ : chr &quot;a&quot;
##  $ : logi [1:3] TRUE FALSE TRUE
##  $ : num [1:2] 2.3 5.9</code></pre>
<p>列表也称为recursive（递归）向量，因为list的元素也可以是list. <code>c()</code>可以把多个列表合成一个，与 <code>list()</code>不同的是它会在合并之前把原子向量强制转化为列表.</p>
<pre class="r"><code>x &lt;- list(list(1, 2), c(3, 4))
y &lt;- c(list(1, 2), c(3, 4))
str(x)</code></pre>
<pre><code>## List of 2
##  $ :List of 2
##   ..$ : num 1
##   ..$ : num 2
##  $ : num [1:2] 3 4</code></pre>
<pre class="r"><code>str(y)</code></pre>
<pre><code>## List of 4
##  $ : num 1
##  $ : num 2
##  $ : num 3
##  $ : num 4</code></pre>
<p>相关函数：</p>
<ul>
<li><code>is.list()</code>,判断是否为列表.</li>
<li><code>as.list()</code>, 强制转换为列表.</li>
<li><code>unlist()</code>，转化为原子向量.</li>
</ul>
<p>列表用于存储复杂的数据，比如数据框是基于列表创建的一类数据.</p>
</div>
</div>
<div class="section level2">
<h2>属性</h2>
<p>任意R对象都可包含额外属性来存储元数据，属性用列表表示（必须含有 names 属性，且 names不能重复, <code>attr()</code>提取特定名字的属性，<code>attributes()</code>列出对象的所有属性.</p>
<pre class="r"><code>y &lt;- 1:10
attr(y, &quot;my_attribute&quot;) &lt;- &quot;This is a vector&quot;
attr(y, &quot;my_attribute&quot;)</code></pre>
<pre><code>## [1] &quot;This is a vector&quot;</code></pre>
<pre class="r"><code>attributes(y) #属性列表</code></pre>
<pre><code>## $my_attribute
## [1] &quot;This is a vector&quot;</code></pre>
<p><code>structure()</code>返回一个新的修改属性后的对象，S3类就是根据这个函数来定义.</p>
<p>修改向量时，默认丢弃除names，dimension和class(s3类)三种属性之外的所有属性. R 中额外定义了函数来访问和修改这三个属性, <code>names()</code>, <code>dim()</code>, 和<code>class()</code>.</p>
<div class="section level3">
<h3>名字属性</h3>
<p>三种方法可以定义 names 属性</p>
<ul>
<li>创建向量时，<code>x &lt;- c(a = 1, b = 2, c = 3)</code></li>
<li>修改已有向量，<code>x &lt;- 1:3; names(x) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code></li>
<li>根据已有向量创建修改的副本，<code>x &lt;- setNames(1:3, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</code></li>
</ul>
<p>三种定义向量 names 的方法对缺少 names 的元素影响各不相同.</p>
<ul>
<li>.</li>
<li>修改已有向量的时候某些元素没有设置 names，这些元素的 names 为<code>NA</code>，如果所有元素都没有 names 那么<code>names(x)</code>返回<code>NULL</code>.</li>
</ul>
<pre class="r"><code># names 为空字符
y &lt;- c(a = 1, 2, 3)
names(y)</code></pre>
<pre><code>## [1] &quot;a&quot; &quot;&quot;  &quot;&quot;</code></pre>
<pre class="r"><code># 修改已有向量的时候某些元素没有设置 names，这些元素的 names 为`NA`
v &lt;- c(1, 2, 3)
names(v) &lt;- c(&#39;a&#39;)
names(v)</code></pre>
<pre><code>## [1] &quot;a&quot; NA  NA</code></pre>
<pre class="r"><code># 所有元素都没有 names 那么`names(x)`返回`NULL`
z &lt;- c(1, 2, 3)
names(z)</code></pre>
<pre><code>## NULL</code></pre>
</div>
<div class="section level3">
<h3>因子</h3>
<p>因子是通过设置 attributes 来定义的S3类，用于存储分类数据，实际上是一个必须包含预定义值的整形原子向量.基于整形向量，通过设置 class 和 levels（预定义值） 两个属性创建因子.</p>
<pre class="r"><code>x &lt;- factor(c(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;))
x</code></pre>
<pre><code>## [1] a b b a
## Levels: a b</code></pre>
<pre class="r"><code>class(x)</code></pre>
<pre><code>## [1] &quot;factor&quot;</code></pre>
<pre class="r"><code>levels(x)</code></pre>
<pre><code>## [1] &quot;a&quot; &quot;b&quot;</code></pre>
<pre class="r"><code>typeof(x)</code></pre>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<p>需要注意的是，当我们从文件读取数据定义一个数值型df时，如果数据中含有特殊字符（非数字) 如“.”，“-”等，那么默认情况下这一列会转化为factor而不是数值型向量，可以通过先把它转化为character然后再转化为数值型向量来正确展示该元素. 还可以通过设置参数<code>na.strings</code>来解决该问题.</p>
<pre class="r"><code>z &lt;- read.csv(text = &quot;value\n12\n1\n.\n9&quot;)
typeof(z$value)</code></pre>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<pre class="r"><code>as.double(z$value) # 3, 2, 1, 4是因子的 level 的索引，而不是读入的数值</code></pre>
<pre><code>## [1] 3 2 1 4</code></pre>
<pre class="r"><code>class(z$value)</code></pre>
<pre><code>## [1] &quot;factor&quot;</code></pre>
<pre class="r"><code>as.double(as.character(z$value)) #先转化为字符向量，在转化为数值型</code></pre>
<pre><code>## Warning: NAs introduced by coercion</code></pre>
<pre><code>## [1] 12  1 NA  9</code></pre>
<pre class="r"><code># 设置 `na.strings`
z &lt;- read.csv(text = &quot;value\n12\n1\n.\n9&quot;, na.strings = &quot;.&quot;)
typeof(z$value)</code></pre>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<pre class="r"><code>class(z$value)</code></pre>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<pre class="r"><code>z$value</code></pre>
<pre><code>## [1] 12  1 NA  9</code></pre>
<p>**R 中几乎所有的数据读入函数默认情况下，会把字符型数据转化为因子.为了避免不需要的麻烦，可以设置参数<code>stringsAsFactors = FALSE</code>,然后需要factor时候再转化.</p>
<p>虽然因子看起来像字符向量，实际上他们是以整型存储的，所以在对因子做字符处理的时候，强烈建议先把它转化为character.**</p>
</div>
</div>
<div class="section level2">
<h2>矩阵和数组</h2>
<p>基于原子向量，设置dim属性，可以构建多维数组、矩阵(2维数组)，矩阵实际上是数组的特例（二维）. <code>matrix()</code>和<code>array()</code>用于构建矩阵和数组.</p>
<pre class="r"><code>a &lt;- matrix(1:6,3)
b &lt;- array(1:12, c(2, 3, 2))

# 原子向量设置 dim 属性
c &lt;- 1:6
dim(c) &lt;- c(3, 2)</code></pre>
<p>常用函数</p>
<ul>
<li><code>nrow()</code>,<code>ncol()</code>，<code>dim()</code>:行列数</li>
<li><code>colnames()</code>,<code>row.names()</code>:元素名称</li>
<li><code>dimnames()</code>:列表，对数组元素命名</li>
<li><code>cbind()</code>,<code>rbind()</code>,<code>abind()</code>:合并</li>
<li><code>t()</code>,<code>aperm()</code>：转置</li>
<li><code>is.*()</code>,<code>as.*()</code>,类型判断和转化</li>
</ul>
<p>此外，基于列表设置dim属性可以构建列表矩阵或者数组</p>
<pre class="r"><code>l &lt;- list(1:3, &quot;a&quot;, TRUE, 1.0)
dim(l) &lt;- c(2, 2)</code></pre>
</div>
<div class="section level2">
<h2>数据框</h2>
<p>数据框是基于列表创建的 S3类，因此 <code>typeof(df)</code>为 <code>list</code>. 数据框中是由一系列相同长度的向量构成,构成了一个2维数据，因此可以称之为向量列表，并且它同时具有列表和矩阵的特性.</p>
<div class="section level3">
<h3>创建</h3>
<p><code>data.frame()</code>通过输入一系列向量来创建数据框,</p>
<pre class="r"><code>df &lt;- data.frame(x = 1:3, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))
str(df)</code></pre>
<pre><code>## &#39;data.frame&#39;:    3 obs. of  2 variables:
##  $ x: int  1 2 3
##  $ y: Factor w/ 3 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;: 1 2 3</code></pre>
<p>显然，<code>data.frame()</code>默认把字符向量转化为因子，建议设置参数<code>stringAsFactors = FALSE</code>.</p>
</div>
<div class="section level3">
<h3>类型检测和转化</h3>
<ul>
<li><code>is.data.frame()</code>或者 <code>class()</code>测试其类型.</li>
<li><code>as.data.frame()</code>转化为数据框
<ul>
<li>向量对象，转化为单列的数据库</li>
<li>列表，列表的每一个元素转换为数据框的一列，因此要求列表元素长度必须相同，否则抛出错误</li>
<li>矩阵，相同行列的数据库</li>
</ul></li>
</ul>
</div>
<div class="section level3">
<h3>合并</h3>
<p><code>rbind()</code>和<code>cbind()</code>用于合并数据库，<code>rbind()</code>要求数据框的列数和列名相同，<code>cbind()</code>要求行数相同，同时忽略行名.</p>
<p><strong>这两个函数是泛型函数，对于数据框的合并仅当至少有一个对象为数据框的时候才有意义，因为它们要求参数类型相同，会在合并之前把所有参数转化为数据框.</strong></p>
</div>
<div class="section level3">
<h3>特殊列</h3>
<p>我们知道数据框是一系列向量构成的列表，因此它的每一列元素也可以是列表，如</p>
<pre class="r"><code>df &lt;- data.frame(x = 1:3)
df$y &lt;- list(1:2, 1:3, 1:4)</code></pre>
<p>然而，利用<code>data.frame()</code>创建数据框的时候，如果参数为列表，会把列表的每一个元素作为数据框的一列. 如果要保持列表参数的原有数据结构，<code>I()</code>创建<code>AsIs</code>类来保持数据原有结构.</p>
<pre class="r"><code>dfl &lt;- data.frame(x = 1:3, y = I(list(1:2, 1:3, 1:4)))
str(dfl)</code></pre>
<pre><code>## &#39;data.frame&#39;:    3 obs. of  2 variables:
##  $ x: int  1 2 3
##  $ y:List of 3
##   ..$ : int  1 2
##   ..$ : int  1 2 3
##   ..$ : int  1 2 3 4
##   ..- attr(*, &quot;class&quot;)= chr &quot;AsIs&quot;</code></pre>
<pre class="r"><code>dfl[3,&quot;y&quot;]</code></pre>
<pre><code>## [[1]]
## [1] 1 2 3 4</code></pre>
<p>类似的，矩阵或者数组也可以作为数据框的元素(行数跟数据框中其他元素一致).</p>
</div>
</div>
