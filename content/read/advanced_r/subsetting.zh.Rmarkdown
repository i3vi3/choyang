---
title: "Subsetting"
author: "Yang"
date: "2018-01-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

R中构造子集的操作符主要有三类，最基础的`[`, `[[`(S4类中是`slot()`), 和`$`(s4类是`@`)。

## `[`对不同的数据结构取子集

### 原子向量

```{r}
x <- c(2.1, 4.2, 3.3, 5.4)
```

正整数，按索引取值

```{r}
x[c(3,1)]

# 实数取整数部分
x[c(3.6, 1.3)]
```

负整数，删除相应元素

```{r, error=TRUE}
x[c(-3, -1)]
x[c(-3.6, -1.3)]

# 正负整数不能混合使用
x[c(-3, 1)]
```

逻辑向量，取`TRUE`位置对应的元素

```{r}
x[c(TRUE, FALSE, TRUE, FALSE)]

# 如果逻辑向量的长度小于原向量，那么重新使用逻辑向量直至与原向量长度一致等价于x[c(TRUE, FALSE, TRUE, FALSE)]
x[c(TRUE, FALSE)]

# 表达式
x[x > 3]

# NA 对应的返回 NA
x[c(NA, TRUE)]
```

nothing,返回向量本身

```{r}
x[]
```

0, 返回长度为0的向量

```{r}
x[0]
```

如果向量已经命名（具有`names`属性），可以使用字符串取值

```{r, error=TRUE}
(y <- setNames(x, letters[1:4]))

y[c("a", "b")]

# 字符串必须精确匹配（不支持模糊匹配），否则返回NA
y["ab"]
```

### 列表

跟原子向量一致，`[`返回一个列表（`[[`和`$`返回列表中的元素）。

### 矩阵和数组

多维数据，类似于一维数据，只是每一维对应的索引用逗号隔开。

```{r}
a <- matrix(1:9, nrow = 3)
colnames(a) <- c("A", "B", "C")

# 空格表示取所有列
a[1:2, ]

# 行用逻辑向量，列用字符串匹配
a[c(TRUE, FALSE, TRUE), c("B", "A")]
```

矩阵和数组是只是在向量基础上添加**dim**属性，所以可以像向量那样对它们取子集（按列排列）

```{r}
# 等价于a[3,1]
a[3]
```

用含有两列的矩阵对二维数据取子集，矩阵的每一行对应取值的位置，每一列对应维度（类似的三列的矩阵可以对三维数组求子集）。

```{r}
# 取第一行第一列和第二行第一列的值
index <- matrix(c(1,1,2,1), byrow = TRUE, ncol = 2)
a[index]
```

需要注意的是，`[`对矩阵和数组的结果默认会简化为可能的最小的维度。

```{r}
# 结果简化为一维向量，而不是二维的单行矩阵
a[1, ]
```

### 数据框

数据框同时具有列表和矩阵的属性，所以对列表和矩阵的取子集的方法都适用于数据框。分别用列表和矩阵取值的方法提取数据库的列

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

# 列表方法
df[c("x", "y")]

# 矩阵方法
df[, c("x", "y")]
```

可以看出，上述两种方法取两列数据不会简化结果为低维度。但是取单列数据的时候，矩阵方法会简化结果为向量。

```{r}
# 数据库
df["x"]

# 向量
df[,"x"]
```


## `[[`和`$`

`[[`类似于`[`，不同的是它只能对一个元素取值，作用于列表时，返回的是列表中元素的具体值。

```{r}
l <- list(a = 1:2, b = 2:3)

# 返回第一个元素
l[[1]]
# 如果为向量，那么会递归索引。取l中第一个元素2:3的第二个元素3。
l[[c(2,2)]]

# [返回列表
l["a"]

# [[返回列表中该元素的值，而不是由该元素构成的列表
l[["a"]]

```

`$`是`[[`是和字符取值的组合的简写。S3和S4类可以自定义`[[`和`[`用法，根据类的不同用法不同。

### 简化（simplifying）或者保留（preserving）

简化结果是指尽可能的简化结果的数据结构，使得我们很容易观察结果，所以适合交互式分析。而保留是指结果和输入的数据结构一致，所以适用于函数编程。对于矩阵和数组可以设置`[`的参数`drop = FALSE`使输出与输入数据结果一直。不同数据类型简化结果不同，如下表所示


|             | Simplifying               | Preserving                                   |
|-------------|---------------------------|----------------------------------------------|
| Vector      | `x[[1]]`                  | `x[1]`                                       |
| List        | `x[[1]]`                  | `x[1]`                                       |
| Factor      | `x[1:4, drop = T]`        | `x[1:4]`                                     |
| Array       | `x[1, ]` __or__ `x[, 1]`  | `x[1, , drop = F]` __or__ `x[, 1, drop = F]` |
| Data frame  | `x[, 1]` __or__ `x[[1]]`  | `x[, 1, drop = F]` __or__ `x[1]`             |

1. 原子向量：删除**names**

```{r}
x <- c(a = 1, b = 2)
x[1]

x[[1]]
```

1. 列表：列表中该元素的值，而不是由该元素构成的长度为1的列表

```{r}
y <- list(a = 1, b = 2)
y[1]

y[[1]]
```

1. 因子：删除没有用到的因子

```{r}
z <- factor(c("a", "b"))
z[1]

z[1, drop = TRUE]
```

1. 矩阵和数组：去除长度为1的维度（矩阵简化为向量）

```{r}
a <- matrix(1:4, nrow = 2)
a[1, , drop = FALSE]

a[1, ]
```

1. 数据框：单列数据简化为向量

```{r}
df <- data.frame(a = 1:2, b = 1:2)

df[1]

df[[1]]

df[1, ,drop = FALSE]
```

### `$`

不同于`[[`，`$`支持模糊匹配，`x$y`等价于x[["y", exact = FALSE]]

```{r}
l <- list(ab = 1, c = 2)

l$a

l[["a"]]
```

可以设置`warnPartialMatchDollar = TRUE`取消模糊匹配。可能引起其他包的函数出错，不建议使用。

需要注意的是使用变量取值的时候`$`容易出错。

```{r}
var <- "cyl"
mtcars$var

# 采用[[
mtcars[[var]]
```

## 取子集赋值

可以通过去子集并赋值的方法修改变量

```{r, warning=TRUE, error=TRUE}
x <- 1:5
x[c(1, 2)] <- 2:3
x

# 左右两边元素长度必须相等，当右边元素个数少于子集时，重新利用直至长度与左边一致
x[c(1,2)] <- 2

# 当右边元素个数多余子集时，丢弃多余的元素并抛出warning
# 第1，2元素分别修改为2，3，丢弃后面的3:5
x[c(1,2)] <- 2:5

# 重复索引，以最后一个为准。
# 第一个元素修改为3
x[c(1, 1)] <- 2:3

# 整数和NA不能一起使用
x[c(1, NA)] <- c(1, 2)

# 逻辑值和NA可以一起使用
# NA对应的位置的元素不修改
x[c(T, F, NA, NA, NA)] <- 1

# 利用表达式返回逻辑值
df <- data.frame(a = c(1, 10, NA))
df$a[df$a < 5] <- 0

df

# 不提供索引，可以保持数据结构不变
# 返回数据框
mtcars[] <- lapply(mtcars, as.integer)
# 返回列表
mtcars <- lapply(mtcars, as.integer)

# 赋值为NULL, 删除list中的元素
x <- list(a = 1, b = 2)
x[["b"]] <- NULL
str(x)

# 添加NULL为list的一个元素, 利用[和list(NULL)赋值。
y <- list(a = 1)
y["b"] <- list(NULL)

str(y)
```



